# Dots and Boxes Game – Game Logic Specification

## 1. 개요
- 목적: Dots and Boxes 게임의 규칙·상태·알고리즘을 구현하기 위한 기술 명세.
- 범위: 보드 모델, 턴 엔진, 체인/루프 탐지, AI 전략 인터페이스, 힌트/리플레이.

## 2. 보드 & 상태 모델

### 2.1 기본 개념
- 격자 크기: `W x H` (점 기준, 예: 5x5 점이면 4x4 상자).
- 점(Dot): 2D 좌표 `(i, j)`.
- 변(Edge): 인접한 두 점 `(i1,j1)-(i2,j2)`.
- 상자(Box): 네 개의 변으로 둘러싸인 사각형.

### 2.2 데이터 구조 (예시)
```ts
// 점 인덱스
interface Dot { i: number; j: number; }

// 변은 두 점의 인덱스 쌍으로 표현
interface Edge {
  a: Dot;
  b: Dot;
}

// 상자 상태
interface BoxState {
  top: boolean;
  right: boolean;
  bottom: boolean;
  left: boolean;
  owner: PlayerId | null;
}

// 전체 보드 상태
interface BoardState {
  width: number;   // 점 기준
  height: number;  // 점 기준
  edges: Set<string>;    // 직렬화된 Edge 키
  boxes: BoxState[][];   // (height-1) x (width-1)
  currentPlayer: PlayerId;
  scores: Record<PlayerId, number>;
  moveHistory: Move[];
}
```

### 2.3 Move 정의
```ts
interface Move {
  player: PlayerId;
  edge: Edge;
  timestamp: number;
  resultedBoxes: { x: number; y: number }[]; // 새로 완성된 상자 좌표
}
```

## 3. 턴 & 룰 엔진

### 3.1 유효 수 검증
- 입력받은 Edge가 다음을 모두 만족해야 함:
  - 보드 범위 내의 두 점을 연결.
  - 상하 혹은 좌우로 인접한 점(대각선은 변형 룰에서만 허용).
  - 이미 존재하는 Edge가 아님.

### 3.2 선 추가 & 상자 판정 알고리즘
1) Edge를 BoardState.edges에 추가.
2) Edge와 인접한 상자(최대 2개)를 찾음.
3) 각 상자에 대해 네 변이 모두 존재하는지 검사.
4) 완성된 상자가 있으면 owner를 현재 플레이어로 설정하고 점수 증가.

### 3.3 턴 전환 규칙
- 기본 규칙:
  - 한 턴에 Edge 하나.
  - 하나 이상 상자를 완성하면 턴 유지, 아니면 다음 플레이어에게 턴 넘김.
- 변형(유아 모드): 상자를 완성해도 항상 턴 교체.

### 3.4 게임 종료 조건
- 가능한 Edge 수 = `(width-1)*height + (height-1)*width`.
- BoardState.edges 수가 이 값에 도달하면 게임 종료.
- 또는 특정 조건(시간 초과, 기권 등)에 의해 조기 종료.

## 4. 체인 & 루프 탐지

### 4.1 정의
- 체인(Chain): 세 변이 그려진 상자들이 변을 공유하며 연속된 경로를 이루는 구간.
- 루프(Loop): 체인이 닫힌 고리를 이루어 시작/끝 상자가 동일한 경우.

### 4.2 탐지 개략 알고리즘
1) 모든 상자를 순회하며, "현재 세 변이 그려진 상자"를 찾는다.
2) 그래프 탐색(DFS/BFS)으로 인접한 세 변 상자들을 연결해 컴포넌트로 묶는다.
3) 각 컴포넌트의 길이를 체인 길이로 정의.
4) 시작 상자로 다시 돌아오는 경로가 존재하면 루프로 마킹.

## 5. AI 봇 인터페이스

### 5.1 공통 인터페이스
```ts
interface BotContext {
  board: BoardState;
  player: PlayerId;
  availableEdges: Edge[];
}

interface BotStrategy {
  name: string;
  level: 'easy' | 'medium' | 'hard';
  selectMove(ctx: BotContext): Edge;
}
```

### 5.2 난이도별 전략 개략
- easy: `availableEdges`에서 무작위 + 이미 세 번째 변이 되는 수는 일정 확률로 회피.
- medium: 세 번째 변을 되도록 피하고, 짧은 체인이 생기면 활용.
- hard: 체인/루프 분석 → 긴 체인은 상대가 열도록 유도 → 이중 교차 패턴 적용.

## 6. 힌트 시스템

### 6.1 힌트 유형
- 안전한 수(Safe Move): 세 번째 변을 만들지 않는 수.
- 위험한 수(Danger Move): 체인/루프를 상대에게 넘겨줄 가능성이 큰 수.
- 전략 힌트: "지금은 체인을 열지 말고 다른 곳을 찾아보자" 등.

### 6.2 힌트 계산 로직 개략
1) 모든 `availableEdges`를 시뮬레이션.
2) 가상의 다음 상태에서 완성 상자/체인 길이 변화를 평가.
3) 간단한 휴리스틱 점수로 정렬 후 상위 몇 개를 힌트 후보로 제시.

## 7. 리플레이 & 로그 포맷

### 7.1 리플레이 저장
- 각 Move를 순서대로 저장(플레이어, Edge, timestamp, resultedBoxes).
- 보드 크기/난이도/룰 변형 플래그를 메타데이터로 포함.

### 7.2 리플레이 재생 로직
1) 초기 BoardState를 생성.
2) Move 리스트를 순회하며, 턴 엔진을 통해 하나씩 적용.
3) UI에서는 일정 간격으로 애니메이션과 함께 재생.

## 8. 오류 처리 & 치트 방지(요약)
- 클라이언트는 요청 전 기본 검증, 서버는 최종 검증.
- 유효하지 않은 Edge 요청은 거절하고 상태를 변경하지 않음.
- 온라인 모드에서는 서버가 단일 진실 소스로 보드 상태를 유지.

## 9. 확장 포인트
- 다양한 변형 보드(삼각/육각 격자) 지원.
- 퍼즐 모드 전용 로직(목표 상태/최적 수 검증).
- LLM 기반 전략 해설 모듈 연동 시, Move 시퀀스를 입력으로 받아 텍스트 코멘트 생성.
